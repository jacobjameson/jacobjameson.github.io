names(icer_values) <- c("A", LETTERS[ordered_indices + 1])
return(icer_values)
})
set.seed(123) # For reproducibility
# Number of simulations
n <- 10000
# Mean and standard deviations for costs and QALYs
mean_costs <- c(20000, 30000, 40000, 60000)
sd_costs <- c(3500, 600, 18200, 9900)
mean_qalys <- c(7.75, 8.20, 8.31, 8.46)
sd_qalys <- c(1.5, 0.3, 4.8, 3.9)
# Simulate costs from a gamma distribution and QALYs from a normal distribution
sim_data <- data.frame(Surgery=replicate(n, {
# Draw costs using the gamma distribution parameters
costs <- rgamma(4, shape=mean_costs^2 / sd_costs^2, scale=sd_costs^2 / mean_costs)
# Draw QALYs from the normal distribution
qalys <- rnorm(4, mean=mean_qalys, sd=sd_qalys)
# Combine the costs and QALYs
cbind(costs, qalys)
}))
# Calculate the ICERs by ordering surgeries by cost and calculating incremental values
icers <- sapply(1:n, function(i) {
surgeries <- sim_data[i,]
ordered_indices <- order(surgeries[1:4])
ordered_costs <- surgeries[ordered_indices]
ordered_qalys <- surgeries[ordered_indices + 4]
# Adding a 'do nothing' option with cost 0 and QALYs 0
incremental_costs <- c(ordered_costs[1], diff(ordered_costs))
incremental_qalys <- c(ordered_qalys[1], diff(ordered_qalys))
# Calculate ICERs
icer_values <- incremental_costs / incremental_qalys
names(icer_values) <- c("A", LETTERS[ordered_indices + 1])
return(icer_values)
})
# Convert list of ICERs to a data frame for plotting
icer_df <- do.call(rbind, icers)
# Calculate the ICERs by ordering surgeries by cost and calculating incremental values
icers <- sapply(1:n, function(i) {
surgeries <- sim_data[i,]
ordered_indices <- order(surgeries[1:4])
ordered_costs <- surgeries[ordered_indices]
ordered_qalys <- surgeries[ordered_indices + 4]
# Adding a 'do nothing' option with cost 0 and QALYs 0
incremental_costs <- c(ordered_costs[1], diff(ordered_costs))
incremental_qalys <- c(ordered_qalys[1], diff(ordered_qalys))
# Calculate ICERs
icer_values <- incremental_costs / incremental_qalys
names(icer_values) <- c("A", LETTERS[ordered_indices + 1])
return(icer_values)
})
set.seed(123) # For reproducibility
# Number of simulations
n <- 10000
# Mean and standard deviations for costs and QALYs
mean_costs <- c(20000, 30000, 40000, 60000)
sd_costs <- c(3500, 600, 18200, 9900)
mean_qalys <- c(7.75, 8.20, 8.31, 8.46)
sd_qalys <- c(1.5, 0.3, 4.8, 3.9)
# Simulate costs from a gamma distribution
sim_costs <- matrix(0, n, length(mean_costs))
for (i in 1:length(mean_costs)) {
shape <- (mean_costs[i] / sd_costs[i])^2
rate <- mean_costs[i] / sd_costs[i]^2
sim_costs[, i] <- rgamma(n, shape = shape, rate = rate)
}
# Simulate QALYs from a normal distribution
sim_qalys <- matrix(0, n, length(mean_qalys))
for (i in 1:length(mean_qalys)) {
sim_qalys[, i] <- rnorm(n, mean = mean_qalys[i], sd = sd_qalys[i])
}
View(sim_costs)
View(sim_costs)
View(sim_qalys)
sim_costs$v0 <- 0
# Simulate costs from a gamma distribution
sim_costs <- matrix(0, n, length(mean_costs))
for (i in 1:length(mean_costs)) {
shape <- (mean_costs[i] / sd_costs[i])^2
rate <- mean_costs[i] / sd_costs[i]^2
sim_costs[, i] <- rgamma(n, shape = shape, rate = rate)
}
sim_costs <- as.data.frame(sim_costs)
sim_costs$V0 <- 0
sim_qalys <- as.data.frame(sim_qalys)
sim_qalys$V0 <- 0
sim costs
sim_costs
glimpse(sim_costs)
library(tidyverse)
glimpse(sim_costs)
glimpse(sim_qalys)
icers <- matrix(nrow = nrow(sim_costs), ncol = ncol(sim_costs) - 1)
# Calculate ICERs for each iteration
for (i in 1:nrow(sim_costs)) {
# Combine costs and QALYs for the current iteration
iteration_data <- data.frame(
cost = sim_costs[i, ],
qalys = sim_qalys[i, ]
)
# Arrange by cost
iteration_data <- iteration_data %>% arrange(cost)
# Calculate incremental costs and QALYs
iteration_data <- iteration_data %>%
mutate(
inc_cost = c(cost[1], diff(cost)),
inc_qalys = c(qalys[1], diff(qalys))
)
# Avoid division by zero for ICER calculation
iteration_data <- iteration_data %>%
mutate(
icer = ifelse(inc_qalys == 0, NA, inc_cost / inc_qalys)
)
# Store the ICERs
icers[i, ] <- iteration_data$icer[-1]
}
View(iteration_data)
sim_costs[1, ]
reshape(sim_costs[1, ])
reshape(sim_costs[1, ], 'long')
reshape(sim_costs[1, ], 'wide')
row <- sim_costs[1, ]
reshape2::melt(row, variable.name = 'Surgery', value.name = 'ICER')
reshape2::melt(row, variable.name = 'Surgery', value.name = 'Cost')
for (i in 2) {
costs_row <- sim_costs[i, ]
costs_row <- reshape2::melt(costs_row, variable.name = 'Surgery', value.name = 'Cost')
qaly_row <- sim_costs[i, ]
qaly_row <- reshape2::melt(qaly_row, variable.name = 'Surgery', value.name = 'Qaly')
merged <- arrange(merge(costs_row, qaly_row, by = 'Surgery'), Cost)
# Calculate the incremental costs and QALYs
}
View(merged)
merged
# differences in costs per row
merged$Cost_diff <- c(0, diff(merged$Cost))
merged
# differences in costs per row
merged$Cost_diff <- diff(merged$Cost)
# differences in costs per row
merged$Cost_diff[2:5] <- diff(merged$Cost)
merged
merged$Cost_diff <- c(0, diff(merged$Cost))
merged
merged$Qaly_diff <- c(0, diff(merged$Qaly))
merged
merged$ICER <- merged$Cost_diff / merged$Qaly_diff
merged
for (i in 2) {
costs_row <- sim_costs[i, ]
costs_row <- reshape2::melt(costs_row, variable.name = 'Surgery', value.name = 'Cost')
qaly_row <- sim_qalys[i, ]
qaly_row <- reshape2::melt(qaly_row, variable.name = 'Surgery', value.name = 'Qaly')
merged <- arrange(merge(costs_row, qaly_row, by = 'Surgery'), Cost)
merged$Cost_diff <- c(0, diff(merged$Cost))
merged$Qaly_diff <- c(0, diff(merged$Qaly))
merged$ICER <- merged$Cost_diff / merged$Qaly_diff
# Calculate the incremental costs and QALYs
}
merged
icers <- as.data.frame()
icers <- data.frame()
icers <- data.frame()
for (i in 1:nrow(sim_costs)) {
costs_row <- sim_costs[i, ]
costs_row <- reshape2::melt(costs_row, variable.name = 'Surgery', value.name = 'Cost')
qaly_row <- sim_qalys[i, ]
qaly_row <- reshape2::melt(qaly_row, variable.name = 'Surgery', value.name = 'Qaly')
merged <- arrange(merge(costs_row, qaly_row, by = 'Surgery'), Cost)
merged$Cost_diff <- c(0, diff(merged$Cost))
merged$Qaly_diff <- c(0, diff(merged$Qaly))
merged$ICER <- merged$Cost_diff / merged$Qaly_diff
icers <- rbind(icers, merged[, c('Surgery', 'ICER')])
}
icers
icers <- data.frame()
for (i in 1:nrow(sim_costs)) {
costs_row <- sim_costs[i, ]
costs_row <- reshape2::melt(costs_row, variable.name = 'Surgery', value.name = 'Cost')
qaly_row <- sim_qalys[i, ]
qaly_row <- reshape2::melt(qaly_row, variable.name = 'Surgery', value.name = 'Qaly')
merged <- arrange(merge(costs_row, qaly_row, by = 'Surgery'), Cost)
merged$Cost_diff <- c(0, diff(merged$Cost))
merged$Qaly_diff <- c(0, diff(merged$Qaly))
merged$ICER <- merged$Cost_diff / merged$Qaly_diff
merged$group <- i
icers <- rbind(icers, merged[, c('Surgery', 'ICER', 'group')])
}
#plot icers for each group
ggplot(icers, aes(x = Surgery, y = ICER, group = group)) +
geom_line(aes(color = factor(group)), alpha = 0.1) +
geom_point(aes(color = factor(group)), alpha = 0.1) +
theme_minimal() +
theme(legend.position = 'none') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
#plot icers for each group
ggplot(icers, aes(x = Surgery, y = ICER, group = group)) +
geom_line(aes(color = factor(group))) +
theme_minimal() +
theme(legend.position = 'none') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
#plot icers for each group
ggplot(icers, aes(color = Surgery, y = ICER, x = group)) +
geom_line(aes(color = factor(group))) +
theme_minimal() +
theme(legend.position = 'none') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
#plot icers for each group
ggplot(icers, aes(color = Surgery, y = ICER, x = group)) +
theme_minimal() +
theme(legend.position = 'none') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
#plot icers for each group
ggplot(icers, aes(color = Surgery, y = ICER, x = group)) +
facet_wrap(~surgery) +
theme_minimal() +
theme(legend.position = 'none') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
#plot icers for each group
ggplot(icers, aes(color = Surgery, y = ICER, x = group)) +
facet_wrap(~Surgery) +
theme_minimal() +
theme(legend.position = 'none') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
View(icers)
#plot icers for each group
ggplot(icers, aes(y = ICER, x = group)) +
facet_wrap(~Surgery) +
theme_minimal() +
theme(legend.position = 'none') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
#plot icers for each group
ggplot(icers, aes(y = ICER, x = group)) +
theme_minimal() +
theme(legend.position = 'none') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
icers
icers <- filter(icers, Surgery != 'V0')
#plot icers for each group
ggplot(icers, aes(y = ICER, x = group)) +
facet_wrap(~Surgery) +
theme_minimal() +
theme(legend.position = 'none') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
#plot icers for each group
ggplot(icers, aes(y = ICER, x = group)) +
geom_point() +
facet_wrap(~Surgery) +
theme_minimal() +
theme(legend.position = 'none') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
#plot icers for each group
ggplot(icers, aes(y = ICER, x = group)) +
geom_line() +
facet_wrap(~Surgery) +
theme_minimal() +
theme(legend.position = 'none') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
#plot icers for each group
ggplot(icers, aes(y = ICER, x = group)) +
geom_point()
#plot icers for each group
ggplot(icers, aes(y = ICER, x = group)) +
geom_point() +
geom_line() +
facet_wrap(~Surgery) +
theme_minimal() +
theme(legend.position = 'none') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
#plot icers for each group
ggplot(icers, aes(y = ICER, x = group, color = Surgery)) +
geom_point() +
geom_line() +
facet_wrap(~Surgery) +
theme_minimal() +
theme(legend.position = 'none') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
set.seed(123) # For reproducibility
# Number of simulations
n <- 100
# Mean and standard deviations for costs and QALYs
mean_costs <- c(20000, 30000, 40000, 60000)
sd_costs <- c(3500, 600, 18200, 9900)
mean_qalys <- c(7.75, 8.20, 8.31, 8.46)
sd_qalys <- c(1.5, 0.3, 4.8, 3.9)
# Simulate costs from a gamma distribution
sim_costs <- matrix(0, n, length(mean_costs))
for (i in 1:length(mean_costs)) {
shape <- (mean_costs[i] / sd_costs[i])^2
rate <- mean_costs[i] / sd_costs[i]^2
sim_costs[, i] <- rgamma(n, shape = shape, rate = rate)
}
sim_costs <- as.data.frame(sim_costs)
sim_costs$V0 <- 0
# Simulate QALYs from a normal distribution
sim_qalys <- matrix(0, n, length(mean_qalys))
for (i in 1:length(mean_qalys)) {
sim_qalys[, i] <- rnorm(n, mean = mean_qalys[i], sd = sd_qalys[i])
}
sim_qalys <- as.data.frame(sim_qalys)
sim_qalys$V0 <- 0
icers <- data.frame()
for (i in 1:nrow(sim_costs)) {
costs_row <- sim_costs[i, ]
costs_row <- reshape2::melt(costs_row, variable.name = 'Surgery', value.name = 'Cost')
qaly_row <- sim_qalys[i, ]
qaly_row <- reshape2::melt(qaly_row, variable.name = 'Surgery', value.name = 'Qaly')
merged <- arrange(merge(costs_row, qaly_row, by = 'Surgery'), Cost)
merged$Cost_diff <- c(0, diff(merged$Cost))
merged$Qaly_diff <- c(0, diff(merged$Qaly))
merged$ICER <- merged$Cost_diff / merged$Qaly_diff
merged$group <- i
icers <- rbind(icers, merged[, c('Surgery', 'ICER', 'group')])
}
icers <- filter(icers, Surgery != 'V0')
#plot icers for each group
ggplot(icers, aes(y = ICER, x = group, color = Surgery)) +
geom_point() +
geom_line() +
theme_minimal() +
theme(legend.position = 'none') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
icers <- data.frame(Surgery = character(), ICER = numeric(), group = integer())
for (i in 1:nrow(sim_costs)) {
costs_row <- data.frame(Surgery = names(sim_costs), Cost = sim_costs[i, ])
qaly_row <- data.frame(Surgery = names(sim_qalys), Qaly = sim_qalys[i, ])
# Combine the costs and QALYs by surgery
merged <- merge(costs_row, qaly_row, by = 'Surgery') %>% arrange(Cost)
# Initialize a flag for the while loop
negative_icer <- TRUE
while (negative_icer) {
# Calculate the differences in cost and QALYs
merged <- merged %>%
mutate(
Cost_diff = c(Cost[1], diff(Cost)),
Qaly_diff = c(Qaly[1], diff(Qaly)),
ICER = Cost_diff / Qaly_diff
)
# Check for negative ICERs
if (any(merged$ICER < 0, na.rm = TRUE)) {
# Filter out the surgery with negative ICER
merged <- merged %>% filter(!(ICER < 0 & !is.na(ICER)))
} else {
negative_icer <- FALSE
}
}
# Add the iteration number as a group
merged$group <- i
# Store the results, excluding the first row which is the 'do nothing' option
icers <- rbind(icers, merged[-1, c('Surgery', 'ICER', 'group')])
}
icers <- data.frame()
for (i in 1:nrow(sim_costs)) {
costs_row <- sim_costs[i, ]
costs_row <- reshape2::melt(costs_row, variable.name = 'Surgery', value.name = 'Cost')
qaly_row <- sim_qalys[i, ]
qaly_row <- reshape2::melt(qaly_row, variable.name = 'Surgery', value.name = 'Qaly')
merged <- arrange(merge(costs_row, qaly_row, by = 'Surgery'), Cost)
negative_icer <- TRUE
while (negative_icer) {
# Calculate the differences in cost and QALYs
merged <- merged %>%
mutate(
Cost_diff = c(Cost[1], diff(Cost)),
Qaly_diff = c(Qaly[1], diff(Qaly)),
ICER = Cost_diff / Qaly_diff
)
# Check for negative ICERs
if (any(merged$ICER < 0, na.rm = TRUE)) {
# Filter out the surgery with negative ICER
merged <- merged %>% filter(!(ICER < 0 & !is.na(ICER)))
} else {
negative_icer <- FALSE
}
}
merged$group <- i
icers <- rbind(icers, merged[, c('Surgery', 'ICER', 'group')])
}
icers <- filter(icers, Surgery != 'V0')
#plot icers for each group
ggplot(icers, aes(y = ICER, x = group, color = Surgery)) +
geom_point() +
geom_line() +
theme_minimal() +
theme(legend.position = 'none') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
#plot icers for each group
ggplot(icers, aes(y = ICER, x = group, color = Surgery)) +
geom_point() +
geom_line() +
theme_bw() +
theme(legend.position = 'right') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
icers <- data.frame()
for (i in 1:nrow(sim_costs)) {
costs_row <- sim_costs[i, ]
costs_row <- reshape2::melt(costs_row, variable.name = 'Surgery', value.name = 'Cost')
qaly_row <- sim_qalys[i, ]
qaly_row <- reshape2::melt(qaly_row, variable.name = 'Surgery', value.name = 'Qaly')
merged <- arrange(merge(costs_row, qaly_row, by = 'Surgery'), Cost)
negative_icer <- TRUE
while (negative_icer) {
# Calculate the differences in cost and QALYs
merged <- merged %>%
mutate(
Cost_diff = c(Cost[1], diff(Cost)),
Qaly_diff = c(Qaly[1], diff(Qaly)),
ICER = Cost_diff / Qaly_diff
)
# Check for negative ICERs
if (any(merged$ICER < 0, na.rm = TRUE)) {
# Filter out the surgery with negative ICER
merged <- merged %>% filter(!(ICER < 0 & !is.na(ICER)))
} else {
negative_icer <- FALSE
}
}
merged$group <- i
icers <- rbind(icers, merged[, c('Surgery', 'ICER', 'group')])
}
View(icers)
#plot icers for each group
ggplot(icers, aes(y = ICER, x = group, color = Surgery)) +
geom_point() +
geom_line() +
theme_bw() +
theme(legend.position = 'right') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
icers <- filter(icers, Surgery != 'V0')
#plot icers for each group
ggplot(icers, aes(y = ICER, x = group, color = Surgery)) +
geom_point() +
geom_line() +
theme_bw() +
theme(legend.position = 'right') +
labs(title = 'ICERs for each group', x = 'Surgery', y = 'ICER')
# Calculate the proportion of times each surgery is optimal
optimal_surgery <- icers %>%
group_by(group) %>%
filter(ICER == min(ICER)) %>%
count(Surgery) %>%
mutate(proportion = n / sum(n))
optimal_surgery
# calculate the proportion of ICERs that are negative
icers %>%
group_by(group) %>%
summarize(negative_ICER = sum(ICER < 0) / n())
icers
# Create a sequence for the range of WTP thresholds
wtp_thresholds <- seq(0, 60000, by = 1000)
# Initialize a list to store the preferred surgery at each WTP threshold
preferred_surgeries <- lapply(wtp_thresholds, function(wtp) {
# For each WTP, initialize a vector to store the preferred surgery for each group
preferred_for_wtp <- integer(nrow(icers) / length(unique(icers$Surgery)))
for (group in unique(icers$group)) {
group_icers <- subset(icers, group == group)
# Filter surgeries with ICER less than or equal to WTP and get the one with the maximum QALY
affordable_surgeries <- subset(group_icers, ICER <= wtp)
if (nrow(affordable_surgeries) > 0) {
preferred_surgery <- affordable_surgeries[which.max(affordable_surgeries$ICER), "Surgery"]
} else {
preferred_surgery <- NA  # No preferred surgery if none are affordable
}
preferred_for_wtp[group] <- preferred_surgery
}
# Return the preferred surgeries for this WTP threshold
table(factor(preferred_for_wtp, levels = unique(icers$Surgery)))
})
# Convert the list to a data frame for easier analysis and plotting
preferred_surgery_df <- do.call(rbind, preferred_surgeries)
rownames(preferred_surgery_df) <- wtp_thresholds
# Convert to long format for plotting
preferred_surgery_long <- reshape2::melt(preferred_surgery_df, variable.name = "Surgery", value.name = "Count")
preferred_surgery_long$WTP <- rep(wtp_thresholds, each = ncol(preferred_surgery_df))
# Calculate the percentage for each WTP and surgery
preferred_surgery_long$Percentage <- with(preferred_surgery_long, Count / sum(Count) * 100)
# Plot the percentage of times each surgery is preferred at each WTP threshold
ggplot(preferred_surgery_long, aes(x = WTP, y = Percentage, color = Surgery)) +
geom_line() +
labs(title = "Percentage of Times Each Surgery is Preferred at WTP Thresholds",
x = "Willingness-to-Pay (WTP) Threshold",
y = "Percentage Preferred") +
theme_minimal()
preferred_surgery_long
View(preferred_surgery_long)
# Create a sequence for the range of WTP thresholds
wtp_thresholds <- seq(0, 60000, by = 1000)
# Initialize a list to store the preferred surgery at each WTP threshold
preferred_surgeries <- lapply(wtp_thresholds, function(wtp) {
# For each WTP, initialize a vector to store the preferred surgery for each group
preferred_for_wtp <- integer(nrow(icers) / length(unique(icers$Surgery)))
for (group in unique(icers$group)) {
group_icers <- subset(icers, group == group)
# Filter surgeries with ICER less than or equal to WTP and get the one with the maximum QALY
affordable_surgeries <- subset(group_icers, ICER <= wtp)
if (nrow(affordable_surgeries) > 0) {
preferred_surgery <- affordable_surgeries[which.max(affordable_surgeries$ICER), "Surgery"]
} else {
preferred_surgery <- NA  # No preferred surgery if none are affordable
}
preferred_for_wtp[group] <- preferred_surgery
}
# Return the preferred surgeries for this WTP threshold
table(factor(preferred_for_wtp, levels = unique(icers$Surgery)))
})
View(preferred_surgeries)
# Convert the list to a data frame for easier analysis and plotting
preferred_surgery_df <- do.call(rbind, preferred_surgeries)
View(preferred_surgery_df)
rownames(preferred_surgery_df) <- wtp_thresholds
# Convert to long format for plotting
preferred_surgery_long <- reshape2::melt(preferred_surgery_df, variable.name = "Surgery", value.name = "Count")
preferred_surgery_long$WTP <- rep(wtp_thresholds, each = ncol(preferred_surgery_df))
