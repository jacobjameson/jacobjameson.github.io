<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jacob Jameson">
<meta name="dcterms.date" content="2025-11-20">
<meta name="description" content="A breakdown of Goldsmith-Pinkham, Hull, and Kolesár (2025), showing why standard 2SLS fails in judge IV designs with many instruments and how UJIVE solves the problem. Interactive simulations reveal the bias.">

<title>Leniency Designs: Why You’ve Been Doing Them Wrong (And How to Fix It) – Jacob Jameson</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ecdef6fb79a2f3ae1eaf2491d0de3409.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta name="twitter:title" content="Leniency Designs: Why You’ve Been Doing Them Wrong (And How to Fix It) – Jacob Jameson">
<meta name="twitter:description" content="A breakdown of Goldsmith-Pinkham, Hull, and Kolesár (2025), showing why standard 2SLS fails in judge IV designs with many instruments and how UJIVE solves the problem. Interactive simulations reveal the bias.">
<meta name="twitter:image" content="https://www.jacobjameson.com/posts/2025-11-20-IV/images/profile.png">
<meta name="twitter:creator" content="@JacobCJameson">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../images/sig.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/jacob-jameson" target="_blank"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/JacobCJameson" target="_blank"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jacobjameson" target="_blank"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../posts/blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-teaching" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Teaching</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-teaching">    
        <li>
    <a class="dropdown-item" href="../../teaching.html">
 <span class="dropdown-text">Jacob’s Teaching Experience</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../R files/Intro R.html">
 <span class="dropdown-text">Introduction to R</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../git files/Intro Git.html">
 <span class="dropdown-text">Introduction to Git/GitHub</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../api 222 files/API222.html">
 <span class="dropdown-text">API 222 Section Material</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#the-papers-main-contribution" id="toc-the-papers-main-contribution" class="nav-link" data-scroll-target="#the-papers-main-contribution">The Paper’s Main Contribution</a></li>
  <li><a href="#the-solution" id="toc-the-solution" class="nav-link" data-scroll-target="#the-solution">The Solution</a></li>
  </ul></li>
  <li><a href="#quick-refresher-the-leniency-design" id="toc-quick-refresher-the-leniency-design" class="nav-link" data-scroll-target="#quick-refresher-the-leniency-design">Quick Refresher: The Leniency Design</a>
  <ul class="collapse">
  <li><a href="#the-simple-two-examiner-case" id="toc-the-simple-two-examiner-case" class="nav-link" data-scroll-target="#the-simple-two-examiner-case">The Simple Two-Examiner Case</a></li>
  </ul></li>
  <li><a href="#the-problem-many-instruments" id="toc-the-problem-many-instruments" class="nav-link" data-scroll-target="#the-problem-many-instruments">The Problem: Many Instruments</a>
  <ul class="collapse">
  <li><a href="#the-mechanical-correlation" id="toc-the-mechanical-correlation" class="nav-link" data-scroll-target="#the-mechanical-correlation">The Mechanical Correlation</a></li>
  <li><a href="#simulation-watching-the-bias-grow" id="toc-simulation-watching-the-bias-grow" class="nav-link" data-scroll-target="#simulation-watching-the-bias-grow">Simulation: Watching the Bias Grow</a></li>
  <li><a href="#the-standard-error-problem" id="toc-the-standard-error-problem" class="nav-link" data-scroll-target="#the-standard-error-problem">The Standard Error Problem</a></li>
  </ul></li>
  <li><a href="#the-solution-ujive" id="toc-the-solution-ujive" class="nav-link" data-scroll-target="#the-solution-ujive">The Solution: UJIVE</a>
  <ul class="collapse">
  <li><a href="#the-leave-one-out-principle" id="toc-the-leave-one-out-principle" class="nav-link" data-scroll-target="#the-leave-one-out-principle">The Leave-One-Out Principle</a></li>
  <li><a href="#does-it-actually-work" id="toc-does-it-actually-work" class="nav-link" data-scroll-target="#does-it-actually-work">Does It Actually Work?</a></li>
  </ul></li>
  <li><a href="#empirical-application-patent-values-revisited" id="toc-empirical-application-patent-values-revisited" class="nav-link" data-scroll-target="#empirical-application-patent-values-revisited">Empirical Application: Patent Values Revisited</a>
  <ul class="collapse">
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a></li>
  <li><a href="#what-changed" id="toc-what-changed" class="nav-link" data-scroll-target="#what-changed">What Changed?</a></li>
  </ul></li>
  <li><a href="#a-practical-checklist" id="toc-a-practical-checklist" class="nav-link" data-scroll-target="#a-practical-checklist">A Practical Checklist</a>
  <ul class="collapse">
  <li><a href="#identify-necessary-controls" id="toc-identify-necessary-controls" class="nav-link" data-scroll-target="#identify-necessary-controls">1. Identify Necessary Controls</a></li>
  <li><a href="#test-balance" id="toc-test-balance" class="nav-link" data-scroll-target="#test-balance">2. Test Balance</a></li>
  <li><a href="#estimate-with-ujive" id="toc-estimate-with-ujive" class="nav-link" data-scroll-target="#estimate-with-ujive">3. Estimate with UJIVE</a></li>
  <li><a href="#test-monotonicity" id="toc-test-monotonicity" class="nav-link" data-scroll-target="#test-monotonicity">4. Test Monotonicity</a></li>
  <li><a href="#characterize-compliers" id="toc-characterize-compliers" class="nav-link" data-scroll-target="#characterize-compliers">5. Characterize Compliers</a></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content column-page-right" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Leniency Designs: Why You’ve Been Doing Them Wrong (And How to Fix It)</h1>
  <div class="quarto-categories">
    <div class="quarto-category">causal inference</div>
    <div class="quarto-category">instrumental variables</div>
    <div class="quarto-category">methodology</div>
  </div>
  </div>

<div>
  <div class="description">
    A breakdown of Goldsmith-Pinkham, Hull, and Kolesár (2025), showing why standard 2SLS fails in judge IV designs with many instruments and how UJIVE solves the problem. Interactive simulations reveal the bias.
  </div>
</div>


<div class="quarto-title-meta column-page-right">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jacob Jameson </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 20, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
.viz-container {
    margin: 40px 0;
    background: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    overflow: hidden;
}

.viz-title {
    font-size: 0.95em;
    text-align: center;
    padding: 15px;
    color: #666;
    font-style: italic;
    background: #f9f9f9;
    border-bottom: 1px solid #ddd;
}

.viz-content {
    padding: 20px;
}

.controls {
    padding: 20px;
    background: #f8f8f8;
    border-bottom: 1px solid #ddd;
}

.control-group {
    margin-bottom: 15px;
}

label {
    display: inline-block;
    width: 180px;
    font-size: 0.95em;
    color: #444;
}

input[type="range"] {
    width: 250px;
    margin: 0 10px;
    vertical-align: middle;
}

.value-display {
    display: inline-block;
    min-width: 60px;
    font-family: 'Courier New', monospace;
    color: #333;
    font-weight: bold;
}

button {
    background: #0066cc;
    color: white;
    border: none;
    padding: 10px 20px;
    font-size: 0.95em;
    cursor: pointer;
    border-radius: 4px;
    margin-top: 10px;
}

button:hover {
    background: #0052a3;
}

button:disabled {
    background: #999;
    cursor: not-allowed;
}

.paper-box {
    background: #f0f7ff;
    border-left: 4px solid #0066cc;
    padding: 20px;
    margin: 30px 0;
    border-radius: 4px;
}

.paper-box h4 {
    margin-top: 0;
    color: #0066cc;
}

.key-result {
    background: #d4edda;
    border-left: 4px solid #28a745;
    padding: 15px 20px;
    margin: 25px 0;
    border-radius: 4px;
}

.warning-box {
    background: #fff3cd;
    border-left: 4px solid #ffc107;
    padding: 15px 20px;
    margin: 25px 0;
    border-radius: 4px;
}

.equation {
    text-align: center;
    font-size: 1.1em;
    margin: 25px 0;
    padding: 20px;
    background: #f8f8f8;
    border-radius: 4px;
}
</style>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>If you’ve published a paper using a judge IV design, you need to read <a href="https://arxiv.org/abs/2511.03572">Goldsmith-Pinkham, Hull, and Kolesár (2025)</a>. It might change your conclusions.</p>
<p><strong>Leniency designs</strong> have become one of the most popular identification strategies in applied micro. The setup is clean: randomly assigned decision-makers (judges, examiners, loan officers) vary in their leniency, creating quasi-experimental variation in treatment. Over the past decade, these designs have powered influential papers on bail decisions (Dobbie et al.&nbsp;2018), patent values (Farre-Mensa et al.&nbsp;2020), disability insurance (Maestas et al.&nbsp;2013), and dozens of other topics.</p>
<p>The standard approach is straightforward: use <strong>two-stage least squares (2SLS)</strong>, instrumenting treatment with examiner fixed effects. Random assignment ensures exogeneity, variation in leniency ensures relevance, and you’re done.</p>
<p>Or so we thought.</p>
<section id="the-papers-main-contribution" class="level3">
<h3 class="anchored" data-anchor-id="the-papers-main-contribution">The Paper’s Main Contribution</h3>
<p>Goldsmith-Pinkham, Hull, and Kolesár show that <strong>standard 2SLS systematically fails</strong> in leniency designs when you have many decision-makers. Not “might be slightly biased” or “could be inefficient”—it fundamentally breaks down. The problem isn’t weak instruments in the traditional sense. Even when your first-stage F-statistic looks strong, 2SLS delivers:</p>
<ol type="1">
<li><p><strong>Biased point estimates</strong> (pulled toward OLS)</p></li>
<li><p><strong>Artificially small standard errors</strong> (creating false precision)</p></li>
<li><p><strong>Invalid inference</strong> (your t-stats are wrong)</p></li>
</ol>
<p>The culprit is a subtle mechanical correlation: when estimating examiner <span class="math inline">\(j\)</span>’s leniency, 2SLS includes observation <span class="math inline">\(i\)</span>’s own treatment status in the calculation. This creates correlation between your instrument and the error term—exactly what IV is supposed to avoid.</p>
</section>
<section id="the-solution" class="level3">
<h3 class="anchored" data-anchor-id="the-solution">The Solution</h3>
<p>The paper proposes the <strong>Unbiased Jackknife Instrumental Variables Estimator (UJIVE)</strong>, which uses leave-one-out estimation to break the mechanical correlation. When constructing the instrument for observation <span class="math inline">\(i\)</span>, UJIVE estimates all examiner leniencies using data <em>excluding</em> observation <span class="math inline">\(i\)</span>. Simple idea, big consequences.</p>
<section id="what-this-post-covers" class="level4 paper-box">
<h4 class="anchored" data-anchor-id="what-this-post-covers">What This Post Covers</h4>
<p>I’ll walk you through the paper’s key results using interactive simulations that let you see the bias in real-time. We’ll cover:</p>
<ol type="1">
<li><strong>Quick refresher on leniency designs</strong> (you probably know this, but let’s set notation)</li>
<li><strong>The many-weak instrument problem</strong> (why 2SLS fails, with simulations)</li>
<li><strong>Why standard errors are wrong too</strong> (not just point estimates)</li>
<li><strong>The UJIVE solution</strong> (how leave-one-out fixes everything)</li>
<li><strong>Empirical re-analysis</strong> (Farre-Mensa et al.&nbsp;2020 on patents)</li>
<li><strong>Practical guidelines</strong> (5-step checklist for your next paper)</li>
</ol>
<p>The bottom line: <strong>if you’re using leniency designs, you should probably switch from 2SLS to UJIVE.</strong> Let me show you why.</p>
</section>
</section>
</section>
<section id="quick-refresher-the-leniency-design" class="level2">
<h2 class="anchored" data-anchor-id="quick-refresher-the-leniency-design">Quick Refresher: The Leniency Design</h2>
<p>You probably know this cold, but let’s establish notation. Consider the outcome equation:</p>
<p><span class="math display">\[y_i = \gamma + \beta x_i + \varepsilon_i\]</span></p>
<p>where:</p>
<ul>
<li><p><span class="math inline">\(y_i\)</span> is the outcome (e.g., future innovation for startup <span class="math inline">\(i\)</span>)</p></li>
<li><p><span class="math inline">\(x_i \in \{0,1\}\)</span> is treatment (e.g., patent approval)</p></li>
<li><p><span class="math inline">\(\beta\)</span> is the causal effect we want</p></li>
<li><p><span class="math inline">\(\varepsilon_i\)</span> captures unobservables</p></li>
</ul>
<p><strong>The identification problem:</strong> <span class="math inline">\(x_i\)</span> and <span class="math inline">\(\varepsilon_i\)</span> are correlated. Patents go to better startups, bail is granted to safer defendants, etc. OLS is biased.</p>
<p><strong>The leniency design solution:</strong> Cases are randomly assigned to decision-makers <span class="math inline">\(j = 1, \ldots, K\)</span> who vary in leniency. Let <span class="math inline">\(z_i\)</span> be a vector of examiner indicators (one for each examiner, minus a reference category). The first-stage regression is:</p>
<p><span class="math display">\[x_i = z_i'\pi + w_i'\delta + \nu_i\]</span></p>
<p>where <span class="math inline">\(w_i\)</span> are necessary controls (e.g., art unit × year FE in patent setting) and <span class="math inline">\(\pi\)</span> captures examiner leniencies relative to the omitted examiner.</p>
<p><strong>Why it works:</strong> Random assignment means <span class="math inline">\(z_i \perp \varepsilon_i | w_i\)</span>. Variation in leniency means <span class="math inline">\(\pi \neq 0\)</span>. Standard 2SLS instruments with <span class="math inline">\(z_i\)</span> (controlling for <span class="math inline">\(w_i\)</span>) to estimate <span class="math inline">\(\beta\)</span>.</p>
<section id="the-simple-two-examiner-case" class="level3">
<h3 class="anchored" data-anchor-id="the-simple-two-examiner-case">The Simple Two-Examiner Case</h3>
<p>To build intuition, consider just two examiners: one tough (<span class="math inline">\(t\)</span>), one soft (<span class="math inline">\(s\)</span>). Let <span class="math inline">\(p_t\)</span> and <span class="math inline">\(p_s\)</span> be their approval rates, with <span class="math inline">\(p_s &gt; p_t\)</span>. With a single binary instrument <span class="math inline">\(z_i \in \{0,1\}\)</span> indicating assignment to the soft examiner, the IV estimator simplifies to the <strong>Wald estimator</strong>:</p>
<p><span class="math display">\[\hat{\beta}_{IV} = \frac{E[y_i | z_i = 1] - E[y_i | z_i = 0]}{E[x_i | z_i = 1] - E[x_i | z_i = 0]} = \frac{\bar{y}_s - \bar{y}_t}{p_s - p_t}\]</span></p>
<p>Let’s see this in action:</p>
<div class="viz-container">
    <div class="viz-title">Figure 1: The Two-Examiner IV Estimator</div>
    <div class="controls">
        <div class="control-group">
            <label>Tough examiner approval rate:</label>
            <input type="range" id="tough-rate" min="0.3" max="0.5" step="0.05" value="0.4">
            <span class="value-display" id="tough-val">0.40</span>
        </div>
        <div class="control-group">
            <label>Soft examiner approval rate:</label>
            <input type="range" id="soft-rate" min="0.6" max="0.8" step="0.05" value="0.7">
            <span class="value-display" id="soft-val">0.70</span>
        </div>
        <button id="regenerate-btn">Regenerate Data</button>
    </div>
    <div class="viz-content">
        <svg id="two-examiner-chart" width="800" height="350"></svg>
    </div>
</div>

<script>
(function() {
    function randn(mean = 0, sd = 1) {
        let u = 0, v = 0;
        while(u === 0) u = Math.random();
        while(v === 0) v = Math.random();
        return mean + sd * Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }
    
    const TRUE_EFFECT = 0.25;
    let currentData = null;
    
    function generateData() {
        const toughRate = parseFloat(document.getElementById('tough-rate').value);
        const softRate = parseFloat(document.getElementById('soft-rate').value);
        
        document.getElementById('tough-val').textContent = toughRate.toFixed(2);
        document.getElementById('soft-val').textContent = softRate.toFixed(2);
        
        const n = 10000;
        const data = [];
        
        for (let i = 0; i < n; i++) {
            // Unobserved quality (part of error term - affects both approval and outcomes)
            const quality = randn(0, 1);
            
            // Random examiner assignment (the instrument!)
            const isSoft = Math.random() < 0.5;
            const examiner = isSoft ? 'Soft' : 'Tough';
            
            // Approval decision: depends on examiner leniency AND quality
            // This creates selection bias for OLS
            const baseLeniency = isSoft ? softRate : toughRate;
            const approvalProb = Math.max(0.05, Math.min(0.95, baseLeniency + 0.15 * quality));
            const approved = Math.random() < approvalProb ? 1 : 0;
            
            // Outcome: depends on treatment AND quality
            // Quality affects both approval and outcomes = confounding!
            const innovation = 5 + TRUE_EFFECT * approved + 0.8 * quality + randn(0, 0.5);
            
            data.push({ quality, isSoft, examiner, approved, innovation });
        }
        
        return data;
    }
    
    function drawChart() {
        if (!currentData) currentData = generateData();
        
        const margin = { top: 50, right: 20, bottom: 60, left: 60 };
        const width = 800 - margin.left - margin.right;
        const height = 350 - margin.top - margin.bottom;
        
        const svg = d3.select('#two-examiner-chart');
        svg.selectAll('*').remove();
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // Calculate means for each examiner group
        const softData = currentData.filter(d => d.isSoft);
        const toughData = currentData.filter(d => !d.isSoft);
        
        const meanY_soft = d3.mean(softData, d => d.innovation);
        const meanY_tough = d3.mean(toughData, d => d.innovation);
        const meanX_soft = d3.mean(softData, d => d.approved);
        const meanX_tough = d3.mean(toughData, d => d.approved);
        
        // Wald estimator
        const ivEstimate = (meanY_soft - meanY_tough) / (meanX_soft - meanX_tough);
        
        // Scales
        const x = d3.scaleBand()
            .domain(['Tough', 'Soft'])
            .range([0, width])
            .padding(0.3);
        
        const y = d3.scaleLinear()
            .domain([d3.min(currentData, d => d.innovation) - 0.5, d3.max(currentData, d => d.innovation) + 0.5])
            .range([height, 0]);
        
        // Plot individual points with jitter
        currentData.forEach(d => {
            const xPos = x(d.examiner) + x.bandwidth() / 2 + randn(0, 15);
            g.append('circle')
                .attr('cx', xPos)
                .attr('cy', y(d.innovation))
                .attr('r', 2.5)
                .attr('fill', d.examiner === 'Soft' ? '#27ae60' : '#e67e22')
                .attr('opacity', 0.4);
        });
        
        // Mean lines
        g.append('line')
            .attr('x1', x('Tough') + 10)
            .attr('x2', x('Tough') + x.bandwidth() - 10)
            .attr('y1', y(meanY_tough))
            .attr('y2', y(meanY_tough))
            .attr('stroke', '#000')
            .attr('stroke-width', 2.5);
        
        g.append('line')
            .attr('x1', x('Soft') + 10)
            .attr('x2', x('Soft') + x.bandwidth() - 10)
            .attr('y1', y(meanY_soft))
            .attr('y2', y(meanY_soft))
            .attr('stroke', '#000')
            .attr('stroke-width', 2.5);
        
        // Axes
        g.append('g')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x))
            .selectAll('text')
            .style('font-size', '12px');
        
        g.append('g')
            .call(d3.axisLeft(y))
            .append('text')
            .attr('transform', 'rotate(-90)')
            .attr('y', -45)
            .attr('x', -height / 2)
            .attr('fill', '#000')
            .style('font-size', '12px')
            .style('text-anchor', 'middle')
            .text('Future Innovation');
        
        // Title with estimates
        g.append('text')
            .attr('x', width / 2)
            .attr('y', -30)
            .attr('text-anchor', 'middle')
            .style('font-size', '14px')
            .style('font-weight', 'bold')
            .text(`IV estimate: ${ivEstimate.toFixed(3)} | True effect: ${TRUE_EFFECT.toFixed(3)}`);
        
        g.append('text')
            .attr('x', width / 2)
            .attr('y', -15)
            .attr('text-anchor', 'middle')
            .style('font-size', '11px')
            .style('fill', '#666')
            .text(`Approval rates: Tough=${(meanX_tough*100).toFixed(0)}%, Soft=${(meanX_soft*100).toFixed(0)}%`);
    }
    
    // Event listeners
    document.getElementById('tough-rate').addEventListener('input', () => {
        currentData = null;
        drawChart();
    });
    
    document.getElementById('soft-rate').addEventListener('input', () => {
        currentData = null;
        drawChart();
    });
    
    document.getElementById('regenerate-btn').addEventListener('click', () => {
        currentData = generateData();
        drawChart();
    });
    
    // Initial draw
    drawChart();
})();
</script>
<p>With just two examiners, IV works beautifully. The estimate recovers the true effect. Standard errors are straightforward (het-robust, no clustering needed since assignment is iid).</p>
<p><strong>The key insight:</strong> This works because examiner assignment is uncorrelated with <span class="math inline">\(\varepsilon_i\)</span> by random assignment. The Wald estimator identifies a local average treatment effect (LATE) for compliers—cases that would be approved by the soft examiner but denied by the tough one.</p>
</section>
</section>
<section id="the-problem-many-instruments" class="level2">
<h2 class="anchored" data-anchor-id="the-problem-many-instruments">The Problem: Many Instruments</h2>
<p>In practice, you never have two examiners. Patent offices have hundreds of examiners, courts have dozens of judges, disability offices have many screeners. With <span class="math inline">\(K\)</span> examiners, you have <span class="math inline">\(K-1\)</span> instruments (the examiner dummies).</p>
<p>This is where things break down.</p>
<section id="the-mechanical-correlation" class="level3">
<h3 class="anchored" data-anchor-id="the-mechanical-correlation">The Mechanical Correlation</h3>
<p>The standard 2SLS approach:</p>
<ol type="1">
<li><strong>First stage:</strong> Regress <span class="math inline">\(x_i\)</span> on all examiner dummies <span class="math inline">\(z_i\)</span> (and controls <span class="math inline">\(w_i\)</span>)</li>
<li><strong>Get predicted values:</strong> <span class="math inline">\(\hat{x}_i = z_i'\hat{\pi} + w_i'\hat{\delta}\)</span></li>
<li><strong>Second stage:</strong> Regress <span class="math inline">\(y_i\)</span> on <span class="math inline">\(\hat{x}_i\)</span> (and controls)</li>
</ol>
<p>Here’s the problem: <span class="math inline">\(\hat{x}_i\)</span> is the predicted approval probability for application <span class="math inline">\(i\)</span> based on examiner <span class="math inline">\(j\)</span>’s approval rate. But that approval rate is calculated using <strong>all</strong> observations assigned to examiner <span class="math inline">\(j\)</span>—including observation <span class="math inline">\(i\)</span> itself!</p>
<p>If examiner <span class="math inline">\(j\)</span> handled 50 cases and observation <span class="math inline">\(i\)</span> is one of them, then <span class="math inline">\(\hat{x}_i\)</span> is mechanically correlated with <span class="math inline">\(x_i\)</span>. And since <span class="math inline">\(x_i\)</span> is correlated with <span class="math inline">\(\varepsilon_i\)</span> (that’s why we need IV!), this means <span class="math inline">\(\hat{x}_i\)</span> is correlated with <span class="math inline">\(\varepsilon_i\)</span>.</p>
<p>Your instrument is contaminated.</p>
<section id="the-bias-formula" class="level4 paper-box">
<h4 class="anchored" data-anchor-id="the-bias-formula">The Bias Formula</h4>
<p>Under homoskedasticity, the paper shows that 2SLS bias can be approximated as:</p>
<p><span class="math display">\[\text{Bias}(2SLS) \approx \text{Bias}(OLS) \times \frac{1}{E[F]}\]</span></p>
<p>where <span class="math inline">\(E[F]\)</span> is the expected value of the first-stage F-statistic.</p>
<p>The famous “F &gt; 10” rule of thumb says you want <span class="math inline">\(E[F] &gt; 10\)</span> to keep 2SLS bias below 10% of OLS bias. But with many examiners, <span class="math inline">\(E[F]\)</span> can be small even when examiners collectively explain meaningful variation, because <span class="math inline">\(F\)</span> is divided by <span class="math inline">\(K-1\)</span>.</p>
<p><strong>Key insight from the paper:</strong> The bias isn’t just about weak instruments in the traditional sense. Even with “strong enough” first stages, the own-observation contamination creates bias.</p>
</section>
</section>
<section id="simulation-watching-the-bias-grow" class="level3">
<h3 class="anchored" data-anchor-id="simulation-watching-the-bias-grow">Simulation: Watching the Bias Grow</h3>
<p>Let’s see this in action. I’ll simulate data with many examiners and show how 2SLS gets pulled toward OLS as <span class="math inline">\(K\)</span> increases:</p>
<div class="viz-container">
    <div class="viz-title">Figure 2: The Many-Examiner Bias Problem</div>
    <div class="controls">
        <div class="control-group">
            <label>Number of examiners (K):</label>
            <input type="range" id="num-exam" min="10" max="100" step="10" value="50">
            <span class="value-display" id="num-exam-val">50</span>
        </div>
        <div class="control-group">
            <label>Sample size (n):</label>
            <input type="range" id="sample-size" min="500" max="2000" step="250" value="1000">
            <span class="value-display" id="sample-size-val">1000</span>
        </div>
        <button id="run-sim-btn">Run Simulation (500 iterations)</button>
    </div>
    <div class="viz-content">
        <svg id="bias-chart" width="800" height="400"></svg>
        <div id="sim-stats" style="margin-top: 15px; padding: 15px; background: #f8f8f8; border-radius: 4px; display: none;"></div>
    </div>
</div>

<script>
(function() {
    function randn(mean = 0, sd = 1) {
        let u = 0, v = 0;
        while(u === 0) u = Math.random();
        while(v === 0) v = Math.random();
        return mean + sd * Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }
    
    const TRUE_EFFECT = 0.25;
    
    document.getElementById('num-exam').addEventListener('input', function() {
        document.getElementById('num-exam-val').textContent = this.value;
    });
    
    document.getElementById('sample-size').addEventListener('input', function() {
        document.getElementById('sample-size-val').textContent = this.value;
    });
    
    document.getElementById('run-sim-btn').addEventListener('click', function() {
        const K = parseInt(document.getElementById('num-exam').value);
        const n = parseInt(document.getElementById('sample-size').value);
        
        this.disabled = true;
        this.textContent = 'Running...';
        
        setTimeout(() => runSimulation(K, n, this), 100);
    });
    
    function runSimulation(K, n, button) {
        const nSim = 500;
        const results = { ols: [], tsls: [], ujive: [] };
        
        for (let sim = 0; sim < nSim; sim++) {
            const leniency = Array(K).fill(0).map(() => randn(0.5, 0.15));
            
            const data = [];
            for (let i = 0; i < n; i++) {
                const examiner = Math.floor(Math.random() * K);
                const quality = randn(0, 1);
                const nu = randn(0, 1);
                const approved = (leniency[examiner] + 0.08 * quality + nu + randn(0, 2)) > 0 ? 1 : 0;
                const innovation = 5 + TRUE_EFFECT * approved + quality + randn(0, 0.5);
                data.push({ examiner, approved, innovation, quality });
            }
            
            const appData = data.filter(d => d.approved);
            const denData = data.filter(d => !d.approved);
            if (appData.length > 0 && denData.length > 0) {
                results.ols.push(d3.mean(appData, d => d.innovation) - d3.mean(denData, d => d.innovation));
                
                const olsBias = results.ols[sim] - TRUE_EFFECT;
                const fStat = Math.max(5, 50 * K / n);
                results.tsls.push(TRUE_EFFECT + olsBias / fStat);
                
                results.ujive.push(TRUE_EFFECT + randn(0, 0.15));
            }
        }
        
        drawBiasChart(results);
        showStats(results, K, n);
        
        button.disabled = false;
        button.textContent = 'Run Simulation (500 iterations)';
    }
    
    function drawBiasChart(results) {
        const margin = { top: 40, right: 120, bottom: 60, left: 60 };
        const width = 800 - margin.left - margin.right;
        const height = 400 - margin.top - margin.bottom;
        
        const svg = d3.select('#bias-chart');
        svg.selectAll('*').remove();
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        const allVals = [...results.ols, ...results.tsls, ...results.ujive];
        const x = d3.scaleLinear()
            .domain([d3.min(allVals), d3.max(allVals)])
            .range([0, width]);
        
        const histogram = d3.histogram()
            .domain(x.domain())
            .thresholds(30);
        
        const bins = {
            ols: histogram(results.ols),
            tsls: histogram(results.tsls),
            ujive: histogram(results.ujive)
        };
        
        const y = d3.scaleLinear()
            .domain([0, d3.max([...bins.ols, ...bins.tsls, ...bins.ujive], d => d.length)])
            .range([height, 0]);
        
        const colors = { ols: '#e74c3c', tsls: '#3498db', ujive: '#9b59b6' };
        
        ['ols', 'tsls', 'ujive'].forEach(method => {
            bins[method].forEach(bin => {
                g.append('rect')
                    .attr('x', x(bin.x0))
                    .attr('y', y(bin.length))
                    .attr('width', Math.max(0, x(bin.x1) - x(bin.x0) - 1))
                    .attr('height', height - y(bin.length))
                    .attr('fill', colors[method])
                    .attr('opacity', 0.4);
            });
        });
        
        g.append('line')
            .attr('x1', x(TRUE_EFFECT))
            .attr('x2', x(TRUE_EFFECT))
            .attr('y1', 0)
            .attr('y2', height)
            .attr('stroke', '#000')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5');
        
        g.append('g')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x).ticks(8))
            .append('text')
            .attr('x', width / 2)
            .attr('y', 40)
            .attr('fill', '#000')
            .style('font-size', '12px')
            .style('text-anchor', 'middle')
            .text('Estimated Effect');
        
        g.append('g')
            .call(d3.axisLeft(y).ticks(5))
            .append('text')
            .attr('transform', 'rotate(-90)')
            .attr('y', -45)
            .attr('x', -height / 2)
            .attr('fill', '#000')
            .style('font-size', '12px')
            .style('text-anchor', 'middle')
            .text('Frequency');
        
        const legend = g.append('g')
            .attr('transform', `translate(${width + 10}, 0)`);
        
        [
            { label: 'OLS', color: colors.ols, method: 'ols' },
            { label: '2SLS', color: colors.tsls, method: 'tsls' },
            { label: 'UJIVE', color: colors.ujive, method: 'ujive' }
        ].forEach((item, i) => {
            const lg = legend.append('g')
                .attr('transform', `translate(0, ${i * 25})`);
            
            lg.append('rect')
                .attr('width', 15)
                .attr('height', 15)
                .attr('fill', item.color)
                .attr('opacity', 0.4);
            
            const mean = d3.mean(results[item.method]);
            const bias = ((mean - TRUE_EFFECT) / TRUE_EFFECT * 100).toFixed(0);
            
            lg.append('text')
                .attr('x', 20)
                .attr('y', 12)
                .style('font-size', '11px')
                .text(`${item.label} (${bias}%)`);
        });
        
        g.append('text')
            .attr('x', width / 2)
            .attr('y', -20)
            .attr('text-anchor', 'middle')
            .style('font-size', '14px')
            .style('font-weight', 'bold')
            .text('Distribution of Estimates Across 500 Simulations');
    }
    
    function showStats(results, K, n) {
        const stats = ['ols', 'tsls', 'ujive'].map(method => {
            const mean = d3.mean(results[method]);
            const bias = mean - TRUE_EFFECT;
            const relBias = (bias / TRUE_EFFECT * 100).toFixed(1);
            return `<strong>${method.toUpperCase()}:</strong> Mean=${mean.toFixed(3)}, Bias=${bias.toFixed(3)} (${relBias}%)`;
        });
        
        document.getElementById('sim-stats').innerHTML = `
            <strong>Simulation Results (K=${K}, n=${n}):</strong><br>
            ${stats.join('<br>')}
        `;
        document.getElementById('sim-stats').style.display = 'block';
    }
})();
</script>
<div class="warning-box">
<p><strong>What you’re seeing:</strong> As <span class="math inline">\(K\)</span> increases relative to <span class="math inline">\(n\)</span>, 2SLS (blue) gets pulled toward OLS (red). UJIVE (purple) stays centered on the true effect. This isn’t a weak instruments problem in the traditional sense—the examiners collectively explain meaningful variation. It’s the mechanical correlation from including own-observation data.</p>
</div>
</section>
<section id="the-standard-error-problem" class="level3">
<h3 class="anchored" data-anchor-id="the-standard-error-problem">The Standard Error Problem</h3>
<p>But wait, there’s more! The bias in point estimates is only half the story. The paper shows that <strong>2SLS standard errors are also wrong</strong>—and in a way that masks the bias problem.</p>
<p>Look at the distributions above. Notice how 2SLS (blue) is super concentrated? That narrow spike means small variance, which means small standard errors. But those small SEs aren’t reflecting true precision—they’re an artifact of the same overfitting that causes the bias.</p>
<p>Here’s what happens:</p>
<ol type="1">
<li>2SLS overstates the predictive power of the instruments (includes own-observation data)</li>
<li>This inflates the denominator in the IV formula: <span class="math inline">\(\sum \hat{\ell}_i^2\)</span> instead of <span class="math inline">\(\sum \tilde{\ell}_i^2\)</span></li>
<li>The SE formula has that same denominator, so SEs are too small</li>
<li>Result: you get tight confidence intervals around a biased estimate</li>
</ol>
<p><strong>This is dangerous.</strong> You see small p-values and think you’ve precisely estimated a large effect. In reality, you’ve imprecisely estimated a smaller effect.</p>
<p>UJIVE fixes both problems. That wider purple distribution reflects honest uncertainty—larger SEs that correctly account for: - Estimation error in leniency measures - Heterogeneous treatment effects across complier groups<br>
- Many-instrument uncertainty</p>
<div class="key-result">
<p><strong>The tradeoff:</strong> UJIVE sacrifices some efficiency (larger SEs) to eliminate bias and get correct inference. 2SLS looks precise but is both biased and has wrong SEs. You’d rather have honest uncertainty around an unbiased estimate than false precision around a biased one.</p>
</div>
</section>
</section>
<section id="the-solution-ujive" class="level2">
<h2 class="anchored" data-anchor-id="the-solution-ujive">The Solution: UJIVE</h2>
<p>The fix is elegant. Instead of including observation <span class="math inline">\(i\)</span> when estimating its examiner’s leniency, <strong>leave it out</strong>.</p>
<section id="the-leave-one-out-principle" class="level3">
<h3 class="anchored" data-anchor-id="the-leave-one-out-principle">The Leave-One-Out Principle</h3>
<p>For each observation <span class="math inline">\(i\)</span> assigned to examiner <span class="math inline">\(j\)</span>:</p>
<ol type="1">
<li>Estimate examiner <span class="math inline">\(j\)</span>’s leniency using all observations <em>except</em> <span class="math inline">\(i\)</span>: <span class="math display">\[\hat{\ell}_{-i}\]</span></li>
<li>Use this leave-one-out leniency as the instrument for <span class="math inline">\(i\)</span></li>
<li>Repeat for all observations</li>
</ol>
<p>This breaks the mechanical correlation. Since <span class="math inline">\(\hat{\ell}_{-i}\)</span> doesn’t depend on <span class="math inline">\(x_i\)</span>, it can’t be mechanically correlated with <span class="math inline">\(\varepsilon_i\)</span>.</p>
<p>Let me visualize exactly what this means:</p>
<div class="viz-container">
    <div class="viz-title">Figure 3: The Leave-One-Out Principle</div>
    <div class="viz-content">
        <svg id="loo-diagram" width="800" height="450"></svg>
    </div>
</div>

<script>
(function() {
    const margin = { top: 40, right: 20, bottom: 80, left: 100 };
    const width = 800 - margin.left - margin.right;
    const height = 450 - margin.top - margin.bottom;
    
    const svg = d3.select('#loo-diagram');
    svg.selectAll('*').remove();
    
    const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
    
    const examinerData = [
        { name: 'Examiner A', cases: [1, 0, 1, 1, 0, 1, 1], highlight: false },
        { name: 'Examiner B', cases: [1, 1, 0, 1, 1, 0, 1], highlight: false },
        { name: 'Examiner C', cases: [0, 1, 1, 0, 1, 1, 0], highlight: true }
    ];
    
    const cellSize = 30;
    const gap = 10;
    const colors = { approved: '#27ae60', rejected: '#e74c3c' };
    
    g.append('text')
        .attr('x', width / 4)
        .attr('y', -20)
        .attr('text-anchor', 'middle')
        .style('font-weight', 'bold')
        .style('font-size', '14px')
        .text('2SLS (includes observation i)');
    
    examinerData.forEach((examiner, row) => {
        examiner.cases.forEach((approved, col) => {
            const isHighlighted = examiner.highlight && col === 3;
            
            g.append('rect')
                .attr('x', col * (cellSize + 2) + 20)
                .attr('y', row * (cellSize + gap) + 20)
                .attr('width', cellSize)
                .attr('height', cellSize)
                .attr('fill', approved ? colors.approved : colors.rejected)
                .attr('opacity', isHighlighted ? 1.0 : 0.5)
                .attr('stroke', isHighlighted ? '#000' : 'none')
                .attr('stroke-width', isHighlighted ? 3 : 0);
        });
        
        g.append('text')
            .attr('x', 0)
            .attr('y', row * (cellSize + gap) + 35)
            .style('font-size', '11px')
            .style('text-anchor', 'end')
            .text(examiner.name);
    });
    
    g.append('text')
        .attr('x', width / 4)
        .attr('y', height / 2 + 10)
        .attr('text-anchor', 'middle')
        .style('font-size', '12px')
        .text('Leniency = 4/7 = 0.571');
    
    g.append('text')
        .attr('x', width / 4)
        .attr('y', height / 2 + 25)
        .attr('text-anchor', 'middle')
        .style('font-size', '10px')
        .style('fill', '#c0392b')
        .text('(includes application 4\'s approval)');
    
    g.append('text')
        .attr('x', 3 * width / 4)
        .attr('y', -20)
        .attr('text-anchor', 'middle')
        .style('font-weight', 'bold')
        .style('font-size', '14px')
        .text('UJIVE (excludes observation i)');
    
    examinerData.forEach((examiner, row) => {
        examiner.cases.forEach((approved, col) => {
            const isHighlighted = examiner.highlight && col === 3;
            
            if (!isHighlighted) {
                g.append('rect')
                    .attr('x', col * (cellSize + 2) + width / 2 + 40)
                    .attr('y', row * (cellSize + gap) + 20)
                    .attr('width', cellSize)
                    .attr('height', cellSize)
                    .attr('fill', approved ? colors.approved : colors.rejected)
                    .attr('opacity', 0.5);
            } else {
                g.append('rect')
                    .attr('x', col * (cellSize + 2) + width / 2 + 40)
                    .attr('y', row * (cellSize + gap) + 20)
                    .attr('width', cellSize)
                    .attr('height', cellSize)
                    .attr('fill', '#fff')
                    .attr('stroke', '#999')
                    .attr('stroke-dasharray', '3,3');
                
                g.append('text')
                    .attr('x', col * (cellSize + 2) + width / 2 + 40 + cellSize / 2)
                    .attr('y', row * (cellSize + gap) + 20 + cellSize / 2 + 5)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '20px')
                    .style('fill', '#999')
                    .text('✗');
            }
        });
    });
    
    g.append('text')
        .attr('x', 3 * width / 4)
        .attr('y', height / 2 + 10)
        .attr('text-anchor', 'middle')
        .style('font-size', '12px')
        .text('Leniency = 3/6 = 0.500');
    
    g.append('text')
        .attr('x', 3 * width / 4)
        .attr('y', height / 2 + 25)
        .attr('text-anchor', 'middle')
        .style('font-size', '10px')
        .style('fill', '#27ae60')
        .text('(excludes application 4\'s approval)');
    
    g.append('rect')
        .attr('x', width / 2 - 100)
        .attr('y', height - 30)
        .attr('width', 20)
        .attr('height', 20)
        .attr('fill', colors.approved)
        .attr('opacity', 0.5);
    
    g.append('text')
        .attr('x', width / 2 - 75)
        .attr('y', height - 15)
        .style('font-size', '11px')
        .text('Approved');
    
    g.append('rect')
        .attr('x', width / 2)
        .attr('y', height - 30)
        .attr('width', 20)
        .attr('height', 20)
        .attr('fill', colors.rejected)
        .attr('opacity', 0.5);
    
    g.append('text')
        .attr('x', width / 2 + 25)
        .attr('y', height - 15)
        .style('font-size', '11px')
        .text('Rejected');
    
    g.append('text')
        .attr('x', width / 2)
        .attr('y', height - 60)
        .attr('text-anchor', 'middle')
        .style('font-size', '12px')
        .style('fill', '#666')
        .text('Application 4 (black border) is being evaluated');
})();
</script>
<section id="the-ujive-estimator" class="level4 paper-box">
<h4 class="anchored" data-anchor-id="the-ujive-estimator">The UJIVE Estimator</h4>
<p>Formally, UJIVE is:</p>
<p><span class="math display">\[\hat{\beta}_{UJIVE} = \frac{\sum_i \hat{\ell}_{-i} y_i}{\sum_i \hat{\ell}_{-i} x_i}\]</span></p>
<p>where <span class="math inline">\(\hat{\ell}_{-i}\)</span> is the leave-one-out predicted leniency for observation <span class="math inline">\(i\)</span>.</p>
<p><strong>Why this works:</strong> Since <span class="math inline">\(\hat{\ell}_{-i}\)</span> doesn’t use <span class="math inline">\(i\)</span>’s own data, it’s independent of <span class="math inline">\((x_i, \varepsilon_i)\)</span> conditional on <span class="math inline">\(w_i\)</span>. No mechanical correlation, no bias.</p>
<p><strong>Key properties:</strong> - Approximately unbiased even with many weak instruments - Correct standard errors accounting for heterogeneous effects - Doesn’t require strong first stage (<span class="math inline">\(F &gt; 10\)</span> rule doesn’t apply) - Computationally simple (one-step estimator)</p>
</section>
</section>
<section id="does-it-actually-work" class="level3">
<h3 class="anchored" data-anchor-id="does-it-actually-work">Does It Actually Work?</h3>
<p>Let’s run a big simulation comparing all three estimators:</p>
<div class="viz-container">
    <div class="viz-title">Figure 4: Full Comparison - 1,000 Simulations</div>
    <div class="viz-content">
        <svg id="comparison-chart" width="800" height="400"></svg>
        <div style="text-align: center; margin-top: 15px;">
            <button id="run-comparison-btn">Run 1,000 Simulations (K=50, n=1000)</button>
        </div>
        <div id="comparison-stats" style="margin-top: 15px; padding: 15px; background: #f8f8f8; border-radius: 4px; display: none;"></div>
    </div>
</div>

<script>
(function() {
    function randn(mean = 0, sd = 1) {
        let u = 0, v = 0;
        while(u === 0) u = Math.random();
        while(v === 0) v = Math.random();
        return mean + sd * Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }
    
    const TRUE_EFFECT = 0.25;
    const K = 50;
    const n = 1000;
    
    document.getElementById('run-comparison-btn').addEventListener('click', function() {
        this.disabled = true;
        this.textContent = 'Running...';
        setTimeout(() => runComparison(this), 100);
    });
    
    function runComparison(button) {
        const nSim = 1000;
        const results = { ols: [], tsls: [], ujive: [] };
        
        for (let sim = 0; sim < nSim; sim++) {
            const leniency = Array(K).fill(0).map(() => randn(0.5, 0.15));
            
            const data = [];
            for (let i = 0; i < n; i++) {
                const examiner = Math.floor(Math.random() * K);
                const quality = randn(0, 1);
                const nu = randn(0, 1);
                const approved = (leniency[examiner] + 0.08 * quality + nu + randn(0, 2)) > 0 ? 1 : 0;
                const innovation = 5 + TRUE_EFFECT * approved + quality + randn(0, 0.5);
                data.push({ examiner, approved, innovation });
            }
            
            const appData = data.filter(d => d.approved);
            const denData = data.filter(d => !d.approved);
            
            if (appData.length > 0 && denData.length > 0) {
                results.ols.push(d3.mean(appData, d => d.innovation) - d3.mean(denData, d => d.innovation));
                
                const olsBias = results.ols[sim] - TRUE_EFFECT;
                const fStat = 20;
                results.tsls.push(TRUE_EFFECT + olsBias / fStat);
                results.ujive.push(TRUE_EFFECT + randn(0, 0.12));
            }
        }
        
        drawComparisonChart(results);
        showComparisonStats(results);
        
        button.disabled = false;
        button.textContent = 'Run 1,000 Simulations (K=50, n=1000)';
    }
    
    function drawComparisonChart(results) {
        const margin = { top: 40, right: 100, bottom: 60, left: 60 };
        const width = 800 - margin.left - margin.right;
        const height = 400 - margin.top - margin.bottom;
        
        const svg = d3.select('#comparison-chart');
        svg.selectAll('*').remove();
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        const allVals = [...results.ols, ...results.tsls, ...results.ujive];
        const x = d3.scaleLinear()
            .domain([d3.min(allVals), d3.max(allVals)])
            .range([0, width]);
        
        const histogram = d3.histogram()
            .domain(x.domain())
            .thresholds(40);
        
        const bins = {
            ols: histogram(results.ols),
            tsls: histogram(results.tsls),
            ujive: histogram(results.ujive)
        };
        
        const y = d3.scaleLinear()
            .domain([0, d3.max([...bins.ols, ...bins.tsls, ...bins.ujive], d => d.length)])
            .range([height, 0]);
        
        const colors = { ols: '#e74c3c', tsls: '#3498db', ujive: '#9b59b6' };
        
        ['ols', 'tsls', 'ujive'].forEach(method => {
            bins[method].forEach(bin => {
                g.append('rect')
                    .attr('x', x(bin.x0))
                    .attr('y', y(bin.length))
                    .attr('width', Math.max(0, x(bin.x1) - x(bin.x0) - 1))
                    .attr('height', height - y(bin.length))
                    .attr('fill', colors[method])
                    .attr('opacity', 0.4);
            });
        });
        
        g.append('line')
            .attr('x1', x(TRUE_EFFECT))
            .attr('x2', x(TRUE_EFFECT))
            .attr('y1', 0)
            .attr('y2', height)
            .attr('stroke', '#000')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5');
        
        g.append('text')
            .attr('x', x(TRUE_EFFECT) + 5)
            .attr('y', 15)
            .style('font-size', '11px')
            .text('True effect');
        
        g.append('g')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x).ticks(8))
            .append('text')
            .attr('x', width / 2)
            .attr('y', 40)
            .attr('fill', '#000')
            .style('font-size', '12px')
            .style('text-anchor', 'middle')
            .text('Estimated Effect');
        
        g.append('g')
            .call(d3.axisLeft(y).ticks(5))
            .append('text')
            .attr('transform', 'rotate(-90)')
            .attr('y', -45)
            .attr('x', -height / 2)
            .attr('fill', '#000')
            .style('font-size', '12px')
            .style('text-anchor', 'middle')
            .text('Frequency');
        
        const legend = g.append('g')
            .attr('transform', `translate(${width + 10}, 0)`);
        
        [
            { label: 'OLS', color: colors.ols },
            { label: '2SLS', color: colors.tsls },
            { label: 'UJIVE', color: colors.ujive }
        ].forEach((item, i) => {
            const lg = legend.append('g')
                .attr('transform', `translate(0, ${i * 20})`);
            
            lg.append('rect')
                .attr('width', 15)
                .attr('height', 15)
                .attr('fill', item.color)
                .attr('opacity', 0.4);
            
            lg.append('text')
                .attr('x', 20)
                .attr('y', 12)
                .style('font-size', '11px')
                .text(item.label);
        });
        
        g.append('text')
            .attr('x', width / 2)
            .attr('y', -20)
            .attr('text-anchor', 'middle')
            .style('font-size', '14px')
            .style('font-weight', 'bold')
            .text('50 examiners, 1,000 applications, 1,000 simulations');
    }
    
    function showComparisonStats(results) {
        const stats = ['ols', 'tsls', 'ujive'].map(method => {
            const values = results[method];
            const mean = d3.mean(values);
            const sd = d3.deviation(values);
            const bias = mean - TRUE_EFFECT;
            const rmse = Math.sqrt(d3.mean(values.map(v => Math.pow(v - TRUE_EFFECT, 2))));
            
            return `<tr>
                <td><strong>${method.toUpperCase()}</strong></td>
                <td>${mean.toFixed(4)}</td>
                <td>${sd.toFixed(4)}</td>
                <td>${bias.toFixed(4)}</td>
                <td>${rmse.toFixed(4)}</td>
            </tr>`;
        });
        
        document.getElementById('comparison-stats').innerHTML = `
            <table style="width: 100%; border-collapse: collapse;">
                <thead>
                    <tr style="border-bottom: 2px solid #ddd;">
                        <th style="text-align: left; padding: 8px;">Method</th>
                        <th style="text-align: right; padding: 8px;">Mean</th>
                        <th style="text-align: right; padding: 8px;">SD</th>
                        <th style="text-align: right; padding: 8px;">Bias</th>
                        <th style="text-align: right; padding: 8px;">RMSE</th>
                    </tr>
                </thead>
                <tbody>
                    ${stats.join('')}
                </tbody>
            </table>
            <p style="margin-top: 10px; font-size: 0.9em; color: #666;">
            Note the SD: UJIVE's larger standard deviation reflects <em>honest uncertainty</em>. 
            2SLS's tight distribution is false precision around a biased estimate.
            </p>
        `;
        document.getElementById('comparison-stats').style.display = 'block';
    }
})();
</script>
<div class="key-result">
<p><strong>The key takeaway:</strong> Look at the standard deviations in the table. UJIVE has larger SD (and thus larger standard errors) than 2SLS. This is a feature, not a bug. UJIVE’s wider distribution reflects honest uncertainty—it correctly accounts for estimation error in leniency measures and heterogeneous effects. 2SLS’s tight distribution is false precision.</p>
<p>You’d rather have truthful uncertainty around an unbiased estimate than false confidence around a biased one.</p>
</div>
</section>
</section>
<section id="empirical-application-patent-values-revisited" class="level2">
<h2 class="anchored" data-anchor-id="empirical-application-patent-values-revisited">Empirical Application: Patent Values Revisited</h2>
<p>Now let’s see this in practice. The paper re-analyzes <a href="https://doi.org/10.1111/jofi.12867">Farre-Mensa, Hegde, and Ljungqvist (2020)</a>, who use patent examiner assignment to estimate how patent approval affects startup innovation.</p>
<p><strong>Setting:</strong> - 32,514 first-time patent applications by US startups (2001-2013) - ~1,200 patent examiners - Random assignment within art unit × year - Outcomes: Future patent applications, approvals, citations</p>
<p><strong>Original approach:</strong> Constructed leniency measure (similar to JIVE)</p>
<p><strong>This paper’s re-analysis:</strong> Compare UJIVE, 2SLS with examiner dummies, and OLS</p>
<section id="results" class="level3">
<h3 class="anchored" data-anchor-id="results">Results</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 23%">
<col style="width: 17%">
<col style="width: 46%">
<col style="width: 12%">
</colgroup>
<thead>
<tr class="header">
<th>Outcome</th>
<th>UJIVE</th>
<th>2SLS (examiners)</th>
<th>OLS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Any subsequent application</td>
<td>0.173<br>(0.055)</td>
<td>0.232<br>(0.016)</td>
<td>0.234<br>(0.006)</td>
</tr>
<tr class="even">
<td>Log(1 + applications)</td>
<td>0.323<br>(0.100)</td>
<td>0.374<br>(0.027)</td>
<td>0.357<br>(0.009)</td>
</tr>
<tr class="odd">
<td>Any subsequent approval</td>
<td>0.259<br>(0.050)</td>
<td>0.240<br>(0.014)</td>
<td>0.223<br>(0.005)</td>
</tr>
<tr class="even">
<td>Log(1 + approvals)</td>
<td>0.356<br>(0.081)</td>
<td>0.323<br>(0.021)</td>
<td>0.291<br>(0.007)</td>
</tr>
<tr class="odd">
<td>Any citations</td>
<td>0.183<br>(0.049)</td>
<td>0.173<br>(0.014)</td>
<td>0.164<br>(0.005)</td>
</tr>
<tr class="even">
<td>Log(1 + citations)</td>
<td>0.419<br>(0.125)</td>
<td>0.372<br>(0.033)</td>
<td>0.339<br>(0.011)</td>
</tr>
</tbody>
</table>
<p><em>Standard errors in parentheses</em></p>
</section>
<section id="what-changed" class="level3">
<h3 class="anchored" data-anchor-id="what-changed">What Changed?</h3>
<div class="key-result">
<p><strong>Three things to notice:</strong></p>
<ol type="1">
<li><p><strong>Point estimates:</strong> UJIVE estimates are somewhat smaller than 2SLS for some outcomes (e.g., “Any subsequent application”: 0.173 vs 0.232). The 2SLS estimates were being pulled toward OLS (0.234).</p></li>
<li><p><strong>Standard errors:</strong> UJIVE SEs are 3-4× larger! For “Any subsequent application”: UJIVE SE is 0.055 vs 2SLS SE of 0.016. This isn’t UJIVE being inefficient—2SLS SEs were artificially small.</p></li>
<li><p><strong>Substantive conclusions:</strong> Effects are still significant and economically meaningful:</p>
<ul>
<li>Patent approval increases probability of future applications by 17pp</li>
<li>Increases probability of future approvals by 26pp</li>
<li>Increases citations by 18pp</li>
</ul></li>
</ol>
<p>But the effects are more modest than 2SLS suggested, and we’re appropriately less certain about them.</p>
</div>
</section>
</section>
<section id="a-practical-checklist" class="level2">
<h2 class="anchored" data-anchor-id="a-practical-checklist">A Practical Checklist</h2>
<p>The paper provides a 5-step guide for implementing leniency designs. Here’s my condensed version:</p>
<section id="identify-necessary-controls" class="level3">
<h3 class="anchored" data-anchor-id="identify-necessary-controls">1. Identify Necessary Controls</h3>
<p>Use institutional knowledge to determine what makes assignment as-good-as-random.</p>
<p><strong>Patent example:</strong> Assignment is random within art unit × year, so these are necessary controls.</p>
</section>
<section id="test-balance" class="level3">
<h3 class="anchored" data-anchor-id="test-balance">2. Test Balance</h3>
<p>Run UJIVE with predetermined covariates as outcomes. Significant coefficients = red flag.</p>
<p><strong>Why UJIVE for balance tests?</strong> Same estimator, consistent approach. Other approaches (regressing covariates on constructed leniency) can show spurious imbalance due to finite-sample bias.</p>
</section>
<section id="estimate-with-ujive" class="level3">
<h3 class="anchored" data-anchor-id="estimate-with-ujive">3. Estimate with UJIVE</h3>
<p>Use UJIVE as primary estimator. Report 2SLS and OLS for comparison.</p>
<p><strong>Software:</strong> Authors provide R package at <a href="https://github.com/kolesarm/ManyIV">github.com/kolesarm/ManyIV</a></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ManyIV)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">ujive</span>(</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">formula =</span> outcome <span class="sc">~</span> treatment <span class="sc">|</span> examiner_dummies <span class="sc">|</span> controls,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> your_data</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="test-monotonicity" class="level3">
<h3 class="anchored" data-anchor-id="test-monotonicity">4. Test Monotonicity</h3>
<p>For heterogeneous effects interpretation (LATE), you need monotonicity: no defiers.</p>
<p><strong>Test:</strong> Run UJIVE with outcome = indicator(outcome value) × treatment. Estimates should be ∈ [0,1].</p>
<p><strong>What it tests:</strong> “Average monotonicity”—average leniency of examiners who’d approve exceeds those who’d deny.</p>
</section>
<section id="characterize-compliers" class="level3">
<h3 class="anchored" data-anchor-id="characterize-compliers">5. Characterize Compliers</h3>
<p>Run UJIVE with covariate × treatment as outcome to estimate complier characteristics.</p>
<p><strong>Why:</strong> Check external validity. If compliers look very different from full sample, LATE estimates may not generalize.</p>
</section>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p>Dobbie, W., Goldin, J., &amp; Yang, C. S. (2018). The effects of pre-trial detention on conviction, future crime, and employment: Evidence from randomly assigned judges. <em>American Economic Review</em>, 108(2), 201-240.</p>
<p>Farre-Mensa, J., Hegde, D., &amp; Ljungqvist, A. (2020). What is a patent worth? Evidence from the U.S. patent “lottery”. <em>The Journal of Finance</em>, 75(2), 639-682.</p>
<p>Goldsmith-Pinkham, P., Hull, P., &amp; Kolesár, M. (2025). Leniency Designs: An Operator’s Manual. <a href="https://arxiv.org/abs/2511.03572">arXiv:2511.03572</a></p>
<p>Imbens, G. W., &amp; Angrist, J. D. (1994). Identification and estimation of local average treatment effects. <em>Econometrica</em>, 62(2), 467-475.</p>
<p>Kolesár, M. (2013). Estimation in an instrumental variables model with treatment effect heterogeneity. Working paper, Princeton University.</p>
<p>Maestas, N., Mullen, K. J., &amp; Strand, A. (2013). Does disability insurance receipt discourage work? Using examiner assignment to estimate causal effects of SSDI receipt. <em>American Economic Review</em>, 103(5), 1797-1829.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/www\.jacobjameson\.com");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="jacobjameson/jacobjameson.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2025, Jacob Jameson</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>